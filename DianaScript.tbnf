shape token
{
    Text: str
}

typealias ast = ImmediateAST

val append : forall 'a. (List['a], 'a) -> List['a]
val extend : forall 'a. (List['a], List['a]) -> List['a]
val empty : forall 'a. () -> List['a]
val resolve_binop : (List[object]) -> ImmediateAST
val to_obj : forall 'a. ('a) -> object
val unesc : (str) -> str
val null : forall 'a. 'a
val mkOGet: (token, ast, ast) -> ast
val mkOSet: (token, ast, ast, ast) -> ast
val mkVal: (token, DObj) -> ast
val mkApp: (token, ast, List[ast]) -> ast
val mkList: (token, List[ast]) -> ast
val mkTuple: (token, List[ast], bool) -> ast
val mkDict: (token, List[(ast, ast)]) -> ast
val mkVar: (token, str) -> ast
val mkInv: (token, ast) -> ast
val mkNeg: (token, ast) -> ast
val mkNot: (token, ast) -> ast
val mkAnd: (token, ast, ast) -> ast
val mkOr: (token, ast, ast) -> ast
val mkIfThen: (token, ast, ast) -> ast
val mkStoreMany: (List[ast], ast) -> ast
val mkNestedIf: (token, List[(ast, ast)], ast) -> ast
val mkFunc: (token, str, List[str], List[ast]) -> ast
val mkLoop: (token, ast) -> ast
val mkFor: (token, str, ast, ast) -> ast
val mkBlock: (token, List[ast]) -> ast
val mkContinue: (token) -> ast
val mkBreak: (token) -> ast
val mkReturn: (token, ast) -> ast
val mkint: (str) -> DObj
val mkfloat: (str) -> DObj
val mkstr: (str) -> DObj
val mknone: () -> DObj
val mkop: (token, str) -> object

val true: bool
val false: bool

start: block <EOF>  { $1 }

list[e] : e  { append(empty(), $1) }
        | list[e] e  { append($1, $2) }


seplist[sep, e]:
      e { append(empty(), $1) }
    | seplist[sep, e] sep e  { append($1, $3) }

nullable[seq] : { empty() }
              | seq { $1 }

optional[a] :   { null }
            | a { $1 }

expr_opt :      { null }
         | expr { $1 }
         

lhs_seq : { empty()  }
        | lhs_seq lhs "="
            { append($1, $2)  }

elifBlock : expr blockOf[then] { ($1, $2) }

snd[a, b] : a b { $2 }

name : <NAME> { $1.Text }
stmt :
    lhs_seq expr { mkStoreMany($1, $2)  }
    | "loop" block "end"
        { mkLoop($1, mkBlock($1, $2))  } 
    | "for" <NAME> "in" expr blockOf[do] "end"
        { mkFor($1, $2.Text, $4, $5) }
    | "break"         { mkBreak($1) }
    | "continue"      { mkContinue($1) }
    | "return"        { mkReturn($1, null) }
    | "return" expr   { mkReturn($1, $2) }
       


then: optional[<NEWLINE>] "then" { $2 }
do: optional[<NEWLINE>] "do" { $2 }

lhs : <NAME>  { mkVar($1, $1.Text) }
    | atom "." "[" expr "]" 
        { mkOGet($2, $1, $4) }
    | atom "." <NAME>  
        { mkOGet($2, $1, mkVal($3, mkstr($3.Text))) }

block : filter[stmt, <NEWLINE>] { $1 }

filter[keep, discard] :
    filter[keep, discard] keep { append($1, $2) }
    | filter[keep, discard] discard { $1 }
    | keep { append(empty(), $1) }
    | discard { empty() }


expr : or_expr  { $1 }

or_expr : or_expr "or" and_expr
            { mkAnd($2, $1, $3)  }
         | and_expr { $1 }

and_expr : and_expr "and" not 
            { mkAnd($2, $1, $3)  }
         | not { $1 }
not : "not" bin { mkNot($1, $2) }
    | bin       { $1 }
    


binop : <SINGLE_BINOP> { mkop($1, $1.Text) }
      | "not" "in"     { mkop($1, "notin") }
      | "-"            { mkop($1, "-") }
       
binseq  : atom    { append(empty(), to_obj($1)) }
        | binseq binop atom   {
           append($1, $2);
           append($1, to_obj($3)) }

bin : binseq { resolve_binop($1) }

trailer : "," { true }
        |     { false }

blockOf[a] : a block { mkBlock($1, $2) }

pair : expr ":" expr  { ($1, $3) }
atom : atom "." "[" expr "]"  { mkOGet($2, $1, $4) }
     | atom "." <NAME>        { mkOGet($2, $1, mkVal($3, mkstr($3.Text))) }
     | atom "(" nullable[seplist[",", expr]] ")" { mkApp($2, $1, $3) }
     | "[" nullable[seplist[",", expr]] "]" { mkList($1, $2) }
     | "(" nullable[seplist[",", expr]] trailer ")" { mkTuple($1, $2, $3) }
     | "{" nullable[seplist[",", pair]] trailer "}" { mkDict($1, $2) }
     | <STR> { mkVal($1, mkstr($1.Text)) }
     | <INT> { mkVal($1, mkint($1.Text)) }
     | <FLOAT> { mkVal($1, mkfloat($1.Text)) }
     | "None"  { mkVal($1, mknone()) }
     | <NAME>  { mkVar($1, $1.Text) }
     | "-" atom  { mkNeg($1, $2) }
     | "~" atom  { mkInv($1, $2) }        
     | "if" expr then block "end"
        { mkIfThen($1, $2, mkBlock($3, $4)) }
     | "if" expr then block
        nullable[list[snd["elif", elifBlock]]]
        optional[blockOf["else"]]
       "end" 
        { 
            let elif = ($2, mkBlock($3, $4)) in
            let elifs = append(empty(), elif) in
            let elifs = extend(elifs, $5) in
            mkNestedIf($1, elifs, $6)
        }
      | "func" name "("  nullable[seplist[",", name]] ")"
            block
        "end" { mkFunc($1, $2, $4, $6) }

%ignore <COMMENT>, <WS_INLINE>

<COMMENT> : "#" (!"\n")*
<SINGLE_BINOP> : ("<" | ">" |">=" | "<=" | "==" | "!=" | "in" | 
          "+" | "*" | "**" | "/" | "//" | "%" |
          "&" | "|" | "<<" | ">>")
<ESCAPED_QUOTE> : "\\\""
<STR> :   "\"" ( ESCAPED_QUOTE | !"\"")* "\""
<WS> : ("\r" | "\t" | "\n" | " ")
<INT> : DIGIT+
<DIGIT> : [0 .. 9]
<FLOAT> : INT "." INT
<UCODE> : [a-z] | [A-Z] | "_" | [\u4e00-\u9fa5]
<NAME>  : UCODE (DIGIT | UCODE)*
<WS_INLINE>: (" " | "\t")+
<CR> : "\r"
<LF> : "\n"
<NEWLINE>: (CR? LF)+
